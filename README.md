# Task 1
Выполняю ``strace -o log_bash.log /bin/bash -c 'cd /tmp'``.  
Просмотр логфайла *log_bash.log* выявляет строку ``chdir("/tmp") ``.  
man 2 chdir сообщает, что chdir является системным вызовом, и изменяет текущий рабочий каталог на путь, указанный
в параметре вызова.  

# Task 2
Визуально проверю вывод команды ``strace file /dev/tty``.  
Интересными к рассмотрению строками является:  
``openat(AT_FDCWD, "/usr/lib/locale/locale-archive", O_RDONLY|O_CLOEXEC) = 3``  
``stat("/home/vagrant/.magic.mgc", 0x7ffc9a973f40) = -1 ENOENT (No such file or directory)``   
``stat("/home/vagrant/.magic", 0x7ffc9a973f40) = -1 ENOENT (No such file or directory)``  
``stat("/etc/magic", {st_mode=S_IFREG|0644, st_size=111, ...}) = 0``  
``openat(AT_FDCWD, "/etc/magic", O_RDONLY) = 3``  
``openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3``  
Файла */home/vagrant/.magic.mgc* в профиле текущего пользователя не найден. Также не найден файл */home/vagrant/.magic*.  
Видно, что успешно открыты и прочитаны файлы */etc/magic* и */usr/share/misc/magic.mgc*. ``cat /etc/magic`` покажет, что в этом файле только закомментированные строки. В свою очередь файл */usr/share/misc/magic.mgc* является символьной ссылкой на файл *../../lib/file/magic.mgс*.  
Команда ``ls -la /lib/file/magic.mgc`` и покажет актуальный файл базы magic для утилиты *file*.  
Для команд ``strace file /dev/sda`` и ``strace file /bin/bash`` - аналогично первому случаю.  
Вывод: БД для утилиты *file* расположена по пути ``/lib/file/magic.mgc``

# Task 3
Для выполнения задания создам тестовую среду.  
В качестве ПО использую *iptraf-ng*. Запущу с правами рута ``iptraf-ng -B -i all -L /root/traflog``. Это заставит утилиту iptraf писать пакеты всех сетевых интерфейсов в файл /root/traflog. Удалю трафлог ``rm /root/traflog``. Тестовая среда создана.   
``ps -C iptraf-ng`` даст PID работающего  процесса. ``lsof -p PID`` покажет открытые файлы процесса. Видно, что файл лога */root/traflog* имеет состояние *deleted*.  
``iptraf-ng 2896 root    6w   REG    8,2    20840 1324076 /root/traflog (deleted)``  
Если дать команду *lsof* несколько раз, то видно, что размер файла увеличивается, поскольку имеется сетевая активность и утилита продолжает писать данные. Задача - сделать размер файла равным нулю. Использую каноничное ``cat /dev/null > /proc/2896/fd/6``, где 2896 - PID процесса iptraf-ng, 6 - файловый дескриптор лога /root/traflog.  
Если повторить *lsof -p 2896*, то увидим, что размер файла стал нулевым или меньшим, чем был (поскольку iptraf-ng продолжает писать лог).   
Уберу за собой. Для корректного завершения работы процесса: ``kill -SIGUSR2 2896``.  

# Task 4
``<defunct>`` процессы или "зомби" остаются после того, как процесс завершил выполнение путем системного вызова *exit*, но при этом существует в таблице процессов. Когда подпроцесс умирает, родитель получает сигнал об этом. В этом случае родительский процесс явным образом смотрит состояние своих подпроцессов через системный вызов wait(). Целью зомби процессов является запоминание системой их PID, чтобы информировать родительский процесс о них по запросу.  
Ресурсов системы зомби процессы не занимают, за исключением нескольких байт памяти в таблице дескрипторов.

# Task 5
<pre>
vagrant@vagrant:~$ sudo /usr/sbin/opensnoop-bpfcc 
PID    COMM               FD ERR PATH
945    vminfo              4   0 /var/run/utmp
582    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
582    dbus-daemon        19   0 /usr/share/dbus-1/system-services
582    dbus-daemon        -1   2 /lib/dbus-1/system-services
582    dbus-daemon        19   0 /var/lib/snapd/dbus-1/system-services/
1      systemd            12   0 /proc/552/cgroup
1      systemd            12   0 /proc/603/cgroup
945    vminfo              4   0 /var/run/utmp
</pre>
В *man opensnoop-bpfcc* сообщается, что эта утилита преднаначена для отслеживания системного вызова *open()*, т.е. с ее помощью можно узнать, какие процессы открывают файлы в текущий момент времени. Это полезно для поиска местоположения файлов, открытых в системе разноообразным ПО. Утилита использует модицифированный Berkeley Packet Filter.

# Task 6

``strace uname -a`` сообщает, что используется системный вызов *uname()*.  
Обращусь к документации: ``man 2 uname``  
<pre>
UNAME(2)                Linux Programmer's Manual               UNAME(2)
NAME         top
       uname - get name and information about current kernel
SYNOPSIS         top
       #include <sys/utsname.h>

       int uname(struct utsname *buf);
DESCRIPTION         top
       uname() returns system information in the structure pointed to by
       buf.  The utsname struct is defined in <sys/utsname.h>:
</pre>

Команда *uname* согласно ``type uname`` является внешним исполняемым файлом, и вызывает syscall *uname()*, после чего форматирует полученные данные.   

# Task 7
Тема - списки команд в bash.  
<pre>
root@netology1:~# test -d /tmp/some_dir; echo Hi
Hi
</pre>
В этом примере команды *test* и *echo* будут выполнены последовательно и независимо от значения exit code; таким образом, строка "Hi" будет
выведена в любом случае, независимо от результата проверки наличия каталога */tmp/some_dir*. Символ ";" используется для простого перечисления 
команд в строке.   
<pre>
root@netology1:~# test -d /tmp/some_dir && echo Hi
root@netology1:~#
</pre>
В этом примере команда *test* вернет ненулевое значение, поскольку каталог */tmp/some_dir* не существует, а в списке команд с помощью && будет выполнено ничего (*echo* не отработает). Согласно man bash, в конструкции *команда1 && команда2* команда 2 будет выполнена лишь в том случае, когда код завершения команды1 будет равен 0 (AND).  
По *set -e*. Эта команда заставил шелл немедленно завершать работу, если любая команда будет иметь ненулевой код выхода. Но если команда с ненулевым exit code является частью цикла until или while, частью условного сравнения if, частью списка && или ||, кроме команды, следующей за последним && или ||, либо статус выхода инвертирован с помощью ! -- то выход из интерпретатора не происходит. Таким образом, нет смысла  конструировать список команд с помощью && и одновременно использовать *set -e*.   

# Task 8
Разберу опции команды set.  
Опция -e: завершает работу текущего инстанса bash, если команды в конвеере, списке или в составной команде (перечисление через ;) имеют ненулевой код выхода. Но если команда с ненулевым exit code является частью цикла until или while, частью условного сравнения if, частью списка && или ||, кроме команды, следующей за последним && или ||, либо статус выхода инвертирован с помощью ! -- то выход из интерпретатора не происходит.  
Опция -u: обрабатывает неустановленные (без значений) переменные, кроме специальных "@" и "*" как ошибки. Выводит сообщение об ошибке и в случае неинтерактивного запуска завершает работу текущего инстанса bash с ненулевым кодом выхода.  
Опция -x: после раскрытия каждой простой команды, for, case, select, или арифметического for отображает расширенное значение переменной подсказки PS4, сопровождаемое командой и  расширенным списком ее аргументов или связанным с ней списком слов.  
Опция -o pipefail: возвращаемое значение конвеера команд устанавливается равным последней (самой правой) команде с ненулевым кодом выхода, либо возвращается 0 в случае успешного выполнения всех команд конвеера. По умолчанию отключена.  
Таким образом, делаю вывод - установка этих опций полезна для глубокой отладки скриптов на языке shell.  

# Task 9
Команда ``ps -ax -o stat=`` даст статус всех процессов системы.  
Для удобства отсортирую вывод ``ps -ax -o stat= | sort | more``. Легко увидеть, что чаще встречаются  статусы "I" и "S". Обращусь к мануалу man 1 ps, глава PROCESS STATE CODES:  
статус I имеют процессы ядра, находящиеся в ожидании (idling);  
статус S имеют процессы в состоянии прерываемого сна (ожидающие событий).  
Чаще всего встречается статус I с флагом < (I<), что  означает, что управление приоритетом это процессов недоступно для пользователя.  
Статус Ss означает, что процесс является лидером сессии (т.е. первый процесс в системе). Sl - процесс многотредовый, а Ssl - процесс многотредовый и является лидером сессии. SN - приоритет процесса может изменять пользователь. Sl+, Ssl+ - знак "+" для идентификатора  группы процессов, которая в данный момент активна и которым разрешено читать и писать в терминал.   

