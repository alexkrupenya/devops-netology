# Task 1

Выясню тип директивы "cd": *type cd*  
Получаю вывод: ``cd is a shell builtin``  
Таким образом, "cd" является встроенной командой bash shell.  

Для выяснения, почему так, а не иначе, обращусь к документации. В книге "Advanced Bash-Scripting Guide", в главе 21 "Subshells", описан процесс
работы bash с внешними утилитами. Если бы "cd" являлась внешней утилитой, то инстанс интепретатора команд для выполнения внешней "cd" форкал бы
подпроцесс. Переменные окружения для этого подпроцесса являются локальными, и не видимы родительскому инстансу. Передача параметра от подпроцесса родителю
является нетривиальной задачей и значительно усложнила бы работу интепретатора команд. Потому было решено сделать эту команду внутренней.

# Task 2
Директива ``grep -c "somestring" < somefile`` даст тот результат, что и ``grep <some_string> <some_file> | wc -l``  
Но выглядит первая конструкция понятнее и содержит только один вызов внешней утилиты *grep*. 

# Task 3
Для решения вопроса использую директиву *ps*. ``ps -q 1 -o comm``.  
На выводе получаю: ``systemd``.  
Проверю: ``ps -C systemd -o pid=``  
На выводе получаю: ``1  1110``  

# Task 4
Запущу VM Ubuntu. Приконнекчусь: ``vagrant ssh``  
Затем создам новую виртуальную сессию: ``screen``  
Командами ``w`` и ``tty`` установим, какие имеются в наличии терминалы.  Вижу ``/dev/pts/0`` основной сессии и ``/dev/pts/1`` сессии screen. Переключаюсь в терминал 0 путем детача сессии screen.   
Перенаправлю поток ошибок из 0 терминала в 1: ``ls zzz > /dev/pts/1 2>&1``  
Аттачу сессию ``screen -d -r``  
Вижу сообщение об ошибке из потока sterr: ``bathcls: cannot access 'zzz': No such file or directory``  
Решено.

# Task 5

Перенаправление файла в stdin и вывод stdout в другой файл осуществим и в unix-системах фундаментален. Пример:  
``grep "shopt" < .bashrc > bashrc_shopts``  
Директива нашла строки, содержащие слово "shopt" в файле .bashrc и вывела их в файл bashrc_shopts  

# Task 6

Да, можно перенаправить вывод из tty в pty и наоборот. Несмотря на то, что pty является псевдо-терминалом и работает в юзерлэнд, а tty - физическим устройством и выполняется в ядре ОС, концепция юникса подразумевает полную интероперабельность. Это легко посмотреть на физической машине. Если послать stdout, например, из /dev/pts/0 виртуального эмулятора терминала в /dev/tty2 физического терминала - то увидим поток stdout на этом физическом терминале. Обратное ровно настолько же верно. Стоит не забывать о правах доступа к указанным устройствам. Как пример: ``cat README.md > /dev/tty2`` пошлет поток по умолчанию (stdout) с любого pts или tty на /dev/tty2.  
Задание выполнялось на физической машине.

# Task 7

Директива ``bash 5>&1`` приведет к созданию файлового дескриптора 5 и перенаправлению stdout в этот поток.  
``echo netology > /proc/$$/fd/5`` выведет слово *netology* в stdout текущего исполняемого инстанса bash. $$ - PID bash, fd - file descriptor, 5 - номер дескриптора, в данном случае это копия stdout. 

# Task 8

Необходимо получить вывод на stdout и stderr. Директива *ls <существующий каталог> <несуществующий каталог>* даст необходимое. Поток stderr передам на вход *grep*, дабы можно было протестировать вывод на экране.  
``ls -al 01234567 /tmp 3>&2 2>&1 1>&3 | grep -n --color "cannot" ``  

На терминальном выводе: цветом выделены номер строки и слово "cannot" как результат работы утилиты *grep*.
Как решалось: 3>&2 - создание дескриптора 3, направленного в stderr; 2>&1 - stderr направлен в stdout; 1>&3 - stdout перенаправлен в дескриптор 3.
Таким образом, на экране видно и стандартный вывод, и по результату работы grep видно перенаправление stderr в stdout.

# Task 9

Директива ``cat /proc/$$/environ`` выведет список переменных окружения текущего инстанса bash. Формат неудобочитаемый, не human reading.
Для вывода списка переменных в удобном для чтения человеком формате можно использовать либо команду ``env``, либо ``printenv``.

# Task 10

man 5 proc сообщает, что */proc* - файловая псевдосистема, дающая доступ к структурам данных ядра.  
Соответственно */proc/PID* - подкаталог с именем, равным идентификатору этого процесса (так называемый pid). Каталог также содержит псевдофайлы и подкаталоги.  
*cmdline* - файл, содержащий полную командную строку запуска процесса, кроме являющихся зомби. Для зомби-процессов файл пуст, попытка чтения файла вернет 0 символов. Командная строка из этого файла является множествов строк, разделенных нулевым байтом.  
*/proc/<PID>/exe* - символьная ссылка, содержащая актуальный путь к исполняемой команде. Эта ссылка может быть разыменована обычным образом; попытка ее открыть приведет к запуску исполняемого файла. Если пусть был разлинкован, строка будет содержать строку ``(deleted)``, добавленную к исходному имени. 

# Task 11

Воспользуюсь структурой /proc. Файл cpuinfo содержит инфорацию о центральном процессоре.  
Директива: ``grep -i --color "sse" /proc/cpuinfo`` даст информацию о поддерживаемых инструкциях CPU.  
Видим, что наиболее свежей версией sse в данном CPU является sse 4.2

# Task 12

``man ssh`` заявляет, что по умолчанию для передачи команды в сессии ssh не запускает tty, для того, чтобы можно было обрабатывать данные непосредственно демоном. Если же команды в строке сесии ssh нет, то ssh считает сессию интерактивной и создает терминал. Чтобы обойти ошибку ``not a tty``, можно воспользоваться ключом -t. В этом случае терминал создается и команда tty выведет его имя, например, ``/dev/pts/1``.

# Task 13

Для Ubuntu 20.04.3 LTS необходимо сразу выполнить в соответствие с ``man reptyr`` следующую директиву: ``echo 0 | sudo tee  /proc/sys/kernel/yama/ptrace_scope``  
После запускаю тестовый процесс ``htop``, отправляю его в фон с помощью Ctrl-Z. Для reptyr необходимо будет знать PID процесса. Узнаю PID командой ``ps -C htop -o pid=``  
Запускаю screen и с помощью команды ``reptyr [PID htop]'`` переношу сессию в текущий терминал. Вижу в списке процессов ``reptyr [PID htop]``, что и является нужным процессом. Детачу сессию screen, смотрю список процессов в исходном терминале. Вижу следующее:   
``   PID TTY          TIME CMD``  
``   2770 pts/2    00:00:24 htop``  
``   2779 pts/0    00:00:00 htop <defunct>``  

# Task 14

Команда tee предназначена для чтения stdin и записи в stdout и в файлы. С ее помощью можно копировать stdin в несколько разных мест, а также в stdout.  
Команда ``sudo echo string > /root/new_file`` не сохранит *string* в *new_file*, так как bash не получит необходимые права доступа. Команда же `` echo string | sudo tee /root/new_file`` корректно запишет значение *string* в *new_file*, поскольку копированием будет заниматься команда *tee*, получившая с помощью *sudo* права на запись в каталог /root.


