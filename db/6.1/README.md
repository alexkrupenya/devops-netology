# Task 1

*Архитектор ПО решил проконсультироваться у вас, какой тип БД лучше выбрать для хранения определенных данных.*

*Он вам предоставил следующие типы сущностей, которые нужно будет хранить в БД:*

* *Электронные чеки в json виде*
* *Склады и автомобильные дороги для логистической компании*
* *Генеалогические деревья*
* *Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации*
* *Отношения клиент-покупка для интернет-магазина*
* *Выберите подходящие типы СУБД для каждой сущности и объясните свой выбор.*

- Электронные чеки в json - это явное требование применять документоориентированную базу данных, оптимизированную именно
для таких случаев хранения;
- Склады и автодороги для логистов требуют применения базы данных графового типа, поскольку решение 
транспортной задачи методом графов красиво выглядит. Графовая БД является реализацией сетевой модели в виде графа.
- Кэш для иденфикаторов целесообразно строить на базе Nosql "ключ-значение", это быстро работает и не требует больших ресурсов, по принципу BASE.
- Генеалогические деревья логично строить в иерархической базе, поскольку имеется пара родителей, от которых
и идут вниз остальные связи.
- Клиент-покупка это реляционная БД, поскольку модель предполагает большое количество разнообразных связей между объектами.

# Task 2

*Вы создали распределенное высоконагруженное приложение и хотите классифицировать его согласно CAP-теореме. Какой классификации по CAP-теореме соответствует ваша система, если (каждый пункт - это отдельная реализация вашей системы и для каждого пункта надо привести классификацию):*

* *Данные записываются на все узлы с задержкой до часа (асинхронная запись)*
* *При сетевых сбоях, система может разделиться на 2 раздельных кластера*
* *Система может не прислать корректный ответ или сбросить соединение*
* *А согласно PACELC-теореме, как бы вы классифицировали данные реализации?* 

1. Данные записываются на все узлы с задержкой до часа (асинхронная запись): CA (consitency и availability).
2. При сетевых сбоях, система может разделиться на 2 раздельных кластера: AP (в этом случае consistency не будет, но availabilty присутствует).
3. Система может не прислать корректный ответ или сбросить соединение: CP (availability отсутствует, но данные в порядке).

Теорема PACELC выглядит как IF P -> (C or A), ELSE (C or L).
По PACELC-теореме ответы на вопрос следующие:
1. Данные записываются на все узлы с задержкой до часа (асинхронная запись): PC/EL; во главе угла целостность данных, система старается быть доступна.
2. При сетевых сбоях, система может разделиться на 2 раздельных кластера: PA/EL; система жертвует целостностью ради доступности.
3. Система может не прислать корректный ответ или сбросить соединение: PA/EC; система доступна, но при этом делает ставку на целостность данных.

# Task 3

*Могут ли в одной системе сочетаться принципы BASE и ACID? Почему?*


ACID(Atomicity, Consistency, Isolation, Durability)
Концепция ACID обеспечивает полную целостность и надежность системы.  
Концепция BASE обеспечивает высокую доступность и производительность системы.  
Свойства ACID означают, что после завершения транзакции ее данные непротиворечивы (технический жаргон: записи согласованы) и стабильны в памяти, куда  могут включаться  различные области и типы памяти.  
Концепция BASE (Basically Available, Soft State, Eventual Consistency) уже в своей аббревиатуре указывает на прерогативу доступности данных над их целостностью и состоянием системы.  
Обе модели созданы для разных целей и предоставляют разный подход к обработке данных.
Таким образом, отдельно взятую СУБД нельзя рассматривать как имеющую ACID+BASE концепцию, поскольку эти концепции противоречат друг другу.  

# Task 4

*Вам дали задачу написать системное решение, основой которого бы послужили:*

* *фиксация некоторых значений с временем жизни*
* *реакция на истечение таймаута*
*Вы слышали о key-value хранилище, которое имеет механизм Pub/Sub. Что это за система? Какие минусы выбора данной системы?*

Для решения задачи с такими требованиями хорошо подходит Redis. Дословный перевод из документации:

*SUBSCRIBE, UNSUBSCRIBE и PUBLISH реализуют парадигму обмена сообщениями Publish/Subscribe, где (цитируя Википедию) отправители (издатели) не запрограммированы на отправку своих сообщений конкретным получателям (подписчикам). Скорее, опубликованные сообщения классифицируются по каналам без знания того, какие (если есть) подписчики могут быть. Подписчики проявляют интерес к одному или нескольким каналам и получают только те сообщения, которые представляют интерес, не зная, какие (если есть) издатели существуют. Такое разделение издателей и подписчиков может обеспечить большую масштабируемость и более динамичную топологию сети.*

Также Redis умеет работать с таймаутами для хранимых значений. Также из документации:

*Redis и сроки действия: ключи с ограниченным сроком жизни. Прежде чем перейти к более сложным структурам данных, нам нужно обсудить еще одну функцию, которая работает независимо от типа значения и называется в Redis сроком действия. По сути, вы можете установить тайм-аут для ключа. Этот таймаут будет являться ограничителем времени жизни. Когда время жизни истекает, ключ автоматически уничтожается, точно так же, как если бы пользователь вызвал команду DEL с ключом.*

Несколько кратких сведений об истечении срока действия в Redis:

*Таймауты могут быть установлены как с точностью до секунд, так и с точностью до миллисекунд. Однако разрешение времени окончания всегда составляет 1 миллисекунду. Информация об истечении срока действия реплицируется и сохраняется на диске, время фактически все равно идет, даже если ваш сервер Redis находится в выключенном состоянии (это означает, что Redis сохраняет дату истечения срока действия ключа на диск).*

Минусы Redis:
- Лимиты памяти. Redis — это база данных в памяти, а это означает, что весь набор данных должен находиться в памяти (ОЗУ). Это может стоить дорого, если планируется иметь большие наборы данных;
- Необходимость постоянной синхронизации данных в ОЗУ и на диске (это делает системный вызов fsync()). Redis делает снапшоты данных для сохранения. При аварии Redis все данные, несинхронизированные с постоянной памятью, будут утеряны.
- Redis не имеет богатого языка запросов (типа SQL). Это не реляционная база, поэтому полнотекстовый поиск по ней сложен. Функции агрегации (типа суммирования) тоже отсутствуют, все возложено на пользовательское приложение. Индексы не поддерживаются ядром СУБД. В общем и целом, все выполняется только командами самого Redis.
- Безопасность. Имеется только базовые опции. Нет механизма назначения прав. Нет шифрования данных. Но указанное можно реализовать в другом программном слое.

Плюсы: Redis исключительно быстр. Просто его нужно правильно готовить и не ставить задачи использовать Redis там, где нужно использовать другие инструменты. 

